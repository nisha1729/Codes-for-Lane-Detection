import cv2
import os
import numpy as np
from matplotlib import pyplot as plt


def getLane(score):

    # Calculate lane position from a probmap
    thr = 0.3
    coordinate = np.zeros(18)
    for i in range(18):
        lineId = np.uint16(287 - i * 20 * 288 / 590)
        line = score[lineId,:]
        value, id = np.max(line), np.argmax(line)
        if np.double(value) / 255 > thr:
            coordinate[i] = id
    if sum(coordinate > 0) < 2:
        coordinate = np.zeros((1, 18))

    return coordinate


# Experiment name
exp = 'vgg_SCNN_DULR_w9'
# Data root
data = ''
# Directory where prob imgs generated by CNN are saved.
probRoot = 'predicts/'+ exp
# Directory to save fitted lanes.
output = 'output/' + exp

testList = data + 'img_list.txt'
show = True  # set to true to visualize
pts = 18
count = 0

with open(testList, 'r') as f_testlist:
    for imname in f_testlist:
        imname = imname.strip()
        count += 1
        if count % 100 == 0:
            print('Processing the %d th image...\n', count)

        existPath = os.path.join(probRoot + os.path.dirname(imname) + '/' + os.path.basename(imname)[0:-4] + '.' + "exist.txt")

        f_exist = open(existPath, 'r')
        exist = f_exist.read()
        coordinates = np.zeros((4, pts))
        for j in range(0,8,2):
            if exist[j]=='1':
                scorePath = os.path.join(probRoot + imname[0:-4] + '_' + str(int(j/2)+1) + '_avg.png')
                scoreMap = cv2.imread(scorePath, cv2.IMREAD_GRAYSCALE)
                coordinate = getLane(scoreMap)
                coordinates[int(j/2),:] = coordinate

        f_exist.close()

        if show:
            img = cv2.imread(os.path.join(data, imname).strip('/'))
            probMaps = np.uint8(np.zeros((288,800,3)))
            plt.imshow(img)
            for j in range(0,8,2):
                color = ['g','b','r','y']
                if exist[j] == '1':
                    j_ = int(j / 2)
                    for m in range(pts):
                        if coordinates[j_,m]>0:
                            plt.plot(np.uint16((coordinates[j_,m]+1)*1640/800),590-m*20,color[j_], marker='.', ms=10)

                    probPath = os.path.join(probRoot + imname[:-4] + '_' + str(j_+1) + '_avg.png').strip('/')
                    probMap = cv2.imread(probPath, cv2.IMREAD_GRAYSCALE)
                    probMaps[:,:,j_%3] = probMaps[:,:,j_%3] + probMap

            plt.show()

            plt.imshow(probMaps)
            probmap_name = os.path.join(probRoot + imname[:-4] + '_probmap.png')
            cv2.imwrite(probmap_name, probMaps)
            plt.show()
        else:
            save_name = os.path.join(output + imname[0:-3] + 'lines.txt')
            position = save_name.find('/')
            prefix = ''
            if position != -1:
                prefix = os.path.dirname(os.path.normpath(save_name))

            if not os.path.isdir(prefix) and prefix != '':
                os.makedirs(prefix)

            fp = open(save_name, 'w')
            for j in range(0,8,2):
                j_ = int(j/2)

                # TODO: Check what happens when a middle lane is skipped
                if exist[j]=='1' and sum(coordinates[j_,:]>0)>1:
                    for m in range(pts):
                        if coordinates[j_,m]>0:
                            # %fprintf('%d %d \n',j,m)
                            fp.write( '%d %d ' % ((np.uint16(coordinates[j_,m]+1)*1640/800), np.uint16(590-(m)*10)))
                            # fp.write('%d %d ' % (np.uint16(coordinates[j_, m]*6000/800) , np.uint16(4000-m*20)))

                    fp.write('\n')

            fp.close()



